# Day 26

### Tick 함수로 Actor의 Transform 조정하기

**1. Transform 속성 이해하기**

- Actor(액터)는 언리얼 엔진에서 게임 세계(월드)에 존재하는 모든 오브젝트를 의미하는데 세 가지 속성을 보유
- 위치 (Location) : 액터가 월드에서 어느 지점에 있는지를 나타냄
- 회전 (Rotation) : 액터가 어느 방향을 바라보는지, 어떤 각도로 기울어져 있는지를 나타냄
- 스케일 (Scale) : 액터의 크기 비율
- FTransform을 활용하면 위치·회전·스케일을 한 번에 다룰 수 있어, Transform 관련 연산을 보다 편리하게 처리할 수 있음
- 위치는 발판을 계속 이동시키는 장애물에 적용시키면 좋을 것 같다.
- 회전은 원의 4분의 1만 사용한 발판에 적용시켜서 난이도 있는 장애물에 사용할 수 있을 것 같다.
- 스케일은 크기가 작아졌다가 커졌다를 반복하는 벽에 적용시키면 점프로 해당 장애물을 넘어가기에 적당한 난이도가 적용될 것 같다.

**2. 좌표계의 개념**

- 월드 좌표계 (World Space) : 게임 전체 세계를 기준으로 한 절대적인 좌표계
- SetActorLocation(), GetActorLocation()처럼 액터 자체를 이동·회전·스케일할 때 대부분 월드 좌표계를 기준으로 함
- 로컬 좌표계 (Local Space) : 액터 자신이나 부모 액터 (또는 부모 컴포넌트)의 Transform을 기준으로 한 상대적인 좌표계
- 계층 구조 (부모-자식 관계)가 있는 경우, 자식은 부모의 Transform에 종속되어 움직임
- GetRelativeTransform(): 부모 기준의 상대 위치·회전·스케일을 가져옴
- SetRelativeLocation(), SetRelativeRotation(): 부모 기준으로 자식의 위치·회전을 조정
- 아직까진 월드 좌표계만 사용하는 것 같지만 추후 상속의 개념 필요시 로컬 좌표계를 이용하여 위치를 조정해야할수도 있을 것 같다.

**3. Tick 함수와 프레임 독립적인 로직 이해하기**

- Tick 함수 활성화하기 : 생성자에서 PrimaryActorTick.bCanEverTick = true; 코드 추가
- DeltaTime이란? : Tick(float DeltaTime) 함수에서 DeltaTime은 "직전 프레임부터 현재 프레임까지 걸린 시간(초)"를 의미
- 단순히 매 프레임마다 X 좌표를 1씩 증가시키면, FPS가 높을수록 더 빨리 움직여 게임 체감 속도가 달라져서 DeltaTime을 곱해서 초 단위 기준으로 이동·회전을 계산해야 함
- 처음에는 이게 왜 필요한가 했었는데 프레임 자체로만 로직을 실행시키면 프레임이 다른 컴퓨터끼리 로직 실행 결과가 차이가 날테니 DeltaTime이 필요하다는 것에 대해서 알게 되었다.

### C++ 클래스와 리플렉션 시스템 활용하기

**1. 리플렉션 시스템 이해하기**

- C++ 클래스의 변수 및 함수 정보를 엔진 내부의 메타데이터 형태로 저장하고, 이를 에디터나 블루프린트에서 활용할 수 있게 만들어주는 기술
- C++ 클래스에 있는 여러 멤버(변수, 함수 등)를 “반사”해, 에디터와 블루프린트에서 직접 설정, 호출이 가능하도록 함
- 프로그래머가 만든 C++ 로직의 뼈대를 디자이너나 다른 팀원들이 에디터에서 직관적으로 조정할 수 있음
- 매개변수를 코드에서만 변경하는 것이 아니라, 에디터에서 바로 조정(슬라이더나 숫자 입력)하여 반복 테스트를 빠르게 진행할 수 있음
- C++ 코드로 작업된 부분의 UI를 건드려야 하는데 C++ 코드를 직접 다루지 않고 언리얼같이 UI 상에서만 작업을 하시는분들 입장에서 해당 부분이 필요할 것 같다.

**2. C++ 클래스 리플렉션에 등록하기**

- 이미 클래스의 헤더 선언에 리플렉션 관련 매크로가 포함되어 있음
- #include "Item.generated.h" : 언리얼 엔진이 자동 생성하는 헤더 파일로, 클래스의 리플렉션 및 엔진 통합에 필요한 코드가 들어있음
- UCLASS() : 해당 클래스를 언리얼 엔진의 리플렉션 시스템에 등록한다는 의미
- GENERATED_BODY() : 언리얼의 코드 생성 도구가 사용하는 코드를 삽입하는 역할을 함
- UCLASS() 매크로의 주요 지정자 : Blueprintable(블루프린트에서 상속 가능), NotBlueprintable(블루프린트에서 이 클래스 상속 불가), BlueprintType(블루프린트에서 변수나 참조로 사용할 수 있게 함)
- #include "Item.generated.h"이 무조건 맨 밑에 있어야만 작동된다는 사실을 처음 알았고 보통 인클루드 순서는 코드 실행에 관계가 없는걸로 아는데 이런 부분이 있다는게 조금 신기했다.

**3. 변수에 리플렉션 적용하기**

- UPROPERTY() 매크로의 주요 지정자 : 에디터에서의 표시 여부나 Blueprint 접근성, 읽기/쓰기 권한 등을 자세하게 설정할 수 있음
- 편집 가능 범위 지정자 : VisibleAnywhere(읽기 전용), EditAnywhere(클래스 기본값, 인스턴스 모두에서 수정 가능), EditDefaultsOnly(클래스 기본값에서만 수정 가능), EditInstanceOnly(인스턴스에서만 수정 가능)
- Blueprint 접근성 지정자 : BlueprintReadWrite(Blueprint 그래프에서 Getter/Setter로 값을 읽거나 쓸 수 있음), BlueprintReadOnly(Blueprint 그래프에서 Getter 핀만 노출되어, 읽기만 가능)
- Category 지정자 : Details 패널에서 이 변수는 범주(폴더) 아래에 표시됨
- UPROPERTY()만 있고, 추가 지정자를 하나도 주지 않을 시 엔진 리플렉션 시스템에는 등록되지만, 에디터나 Blueprint에 노출되지는 않음
- 해당 지정자를 잘 사용해야 수정 권한도 적절히 분배될 것 같고 언리얼에서도 해당 부분들을 확인할 수 있어서 더욱 편할 것 같다.

**4. 함수에 리플렉션 적용하기**

- 함수 리플렉션이란? : 함수 또한 블루프린트에서 직접 호출할 수 있도록 등록할 수 있고 이렇게 하면, 복잡한 C++ 로직을 Blueprint에서 간단한 노드로 불러와 제어할 수 있으므로 작업 효율이 높아짐
- C++에서 만든 함수를 Blueprint 노드로 노출하고 싶을 때, UFUNCTION() 매크로를 사용
- UFUNCTION() 매크로의 주요 지정자
- Blueprint 관련 지정자 : BlueprintCallable(Blueprint 이벤트 그래프(노드)에서 호출(Execute) 가능한 함수로 만듬), BlueprintPure(Getter 역할), BlueprintImplementableEvent(함수의 선언만 C++에 있고, 구현은 블루프린트에서 진행)
- UFUNCTION()에 지정자를 하나도 쓰지 않았다면? : UPROPERTY()와 마찬가지로, 함수가 언리얼 리플렉션에 등록되긴 하지만, 특별히 Blueprint에 노출되지는 않음
- 함수도 UPROPERTY()랑 비슷한 개념이라는거는 처음 알게되었고 BlueprintImplementableEvent 지정자를 사용하면 실제 로직 구현을 언리얼에서 해야한다는게 신기했고 해당 부분은 C++ 코드를 실제로 다루지 않는 분들이 유용하게 쓸 것 같다.
